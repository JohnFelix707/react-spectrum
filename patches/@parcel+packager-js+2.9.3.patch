diff --git a/node_modules/@parcel/packager-js/lib/ScopeHoistingPackager.js b/node_modules/@parcel/packager-js/lib/ScopeHoistingPackager.js
index f8ef750..48a914b 100644
--- a/node_modules/@parcel/packager-js/lib/ScopeHoistingPackager.js
+++ b/node_modules/@parcel/packager-js/lib/ScopeHoistingPackager.js
@@ -93,6 +93,7 @@ class ScopeHoistingPackager {
   hoistedRequires = new Map();
   needsPrelude = false;
   usedHelpers = new Set();
+  externalAssets = new Set();
   constructor(options, bundleGraph, bundle, parcelRequireName) {
     this.options = options;
     this.bundleGraph = bundleGraph;
@@ -114,9 +115,21 @@ class ScopeHoistingPackager {
     // of each bundle group pointing at the sibling bundles. These can be
     // picked up by another bundler later at which point runtimes will be added.
     if (this.bundle.env.isLibrary || this.bundle.env.outputFormat === 'commonjs') {
-      let bundles = this.bundleGraph.getReferencedBundles(this.bundle);
-      for (let b of bundles) {
-        this.externals.set((0, _utils().relativeBundlePath)(this.bundle, b), new Map());
+      for (let b of this.bundleGraph.getReferencedBundles(this.bundle)) {
+        let entry = b.getMainEntry();
+        let symbols = new Map();
+        if (entry && !this.isAsyncBundle && entry.type === 'js') {
+          this.externalAssets.add(entry);
+          let usedSymbols = this.bundleGraph.getUsedSymbols(entry) || new Set();
+          for (let s of usedSymbols) {
+            let imported = s;
+            if (imported === '*' && this.bundle.env.outputFormat === 'esmodule') {
+              imported = 'default';
+            }
+            symbols.set(imported, this.getSymbolResolution(entry, entry, s));
+          }
+        }
+        this.externals.set((0, _utils().relativeBundlePath)(this.bundle, b), symbols);
       }
     }
     let res = '';
@@ -364,7 +377,7 @@ class ScopeHoistingPackager {
       code = code.replace('$parcel$filenameReplace', relPath);
     }
     let [depMap, replacements] = this.buildReplacements(asset, deps);
-    let [prepend, prependLines, append] = this.buildAssetPrelude(asset, deps);
+    let [prepend, prependLines, append] = this.buildAssetPrelude(asset, deps, replacements);
     if (prependLines > 0) {
       sourceMap === null || sourceMap === void 0 ? void 0 : sourceMap.offsetLines(1, prependLines);
       code = prepend + code;
@@ -602,6 +615,9 @@ ${code}
       }
     }
   }
+  isWrapped(resolved, parentAsset) {
+    return !this.bundle.hasAsset(resolved) && !this.externalAssets.has(resolved) || this.wrappedAssets.has(resolved.id) && resolved !== parentAsset;
+  }
   getSymbolResolution(parentAsset, resolved, imported, dep) {
     var _resolvedAsset$symbol;
     let {
@@ -614,10 +630,14 @@ ${code}
       // that is actually unused but we still need a placeholder value.
       return '{}';
     }
-    let isWrapped = !this.bundle.hasAsset(resolvedAsset) || this.wrappedAssets.has(resolvedAsset.id) && resolvedAsset !== parentAsset;
+    let isWrapped = this.isWrapped(resolvedAsset, parentAsset);
     let staticExports = resolvedAsset.meta.staticExports !== false;
     let publicId = this.bundleGraph.getAssetPublicId(resolvedAsset);
 
+    // External CommonJS dependencies need to be accessed as an object property rather than imported
+    // directly to maintain live binding.
+    let isExternalCommonJS = !isWrapped && this.bundle.env.isLibrary && this.bundle.env.outputFormat === 'commonjs' && !this.bundle.hasAsset(resolvedAsset);
+
     // If the resolved asset is wrapped, but imported at the top-level by this asset,
     // then we hoist parcelRequire calls to the top of this asset so side effects run immediately.
     if (isWrapped && dep && !(dep !== null && dep !== void 0 && dep.meta.shouldWrap) && symbol !== false && (
@@ -656,7 +676,7 @@ ${code}
       } else {
         return obj;
       }
-    } else if ((!staticExports || isWrapped || !symbol) && resolvedAsset !== parentAsset) {
+    } else if ((!staticExports || isWrapped || !symbol || isExternalCommonJS) && resolvedAsset !== parentAsset) {
       // If the resolved asset is wrapped or has non-static exports,
       // we need to use a member access off the namespace object rather
       // than a direct reference. If importing default from a CJS module,
@@ -681,7 +701,7 @@ ${code}
     let hoisted = this.hoistedRequires.get(dep.id);
     let res = '';
     let lineCount = 0;
-    let isWrapped = !this.bundle.hasAsset(resolved) || this.wrappedAssets.has(resolved.id) && resolved !== parentAsset;
+    let isWrapped = this.isWrapped(resolved, parentAsset);
 
     // If the resolved asset is wrapped and is imported in the top-level by this asset,
     // we need to run side effects when this asset runs. If the resolved asset is not
@@ -698,7 +718,7 @@ ${code}
     }
     return [res, lineCount];
   }
-  buildAssetPrelude(asset, deps) {
+  buildAssetPrelude(asset, deps, replacements) {
     let prepend = '';
     let prependLineCount = 0;
     let append = '';
@@ -823,6 +843,7 @@ ${code}
         prepend += `\n${usedExports.map(exp => {
           var _asset$symbols$get2, _asset$symbols$get2$m;
           let resolved = this.getSymbolResolution(asset, asset, exp);
+          resolved = replacements.get(resolved) || resolved;
           let get = this.buildFunctionExpression([], resolved);
           let isEsmExport = !!((_asset$symbols$get2 = asset.symbols.get(exp)) !== null && _asset$symbols$get2 !== void 0 && (_asset$symbols$get2$m = _asset$symbols$get2.meta) !== null && _asset$symbols$get2$m !== void 0 && _asset$symbols$get2$m.isEsm);
           let set = !isEsmExport && asset.meta.hasCJSExports ? ', ' + this.buildFunctionExpression(['v'], `${resolved} = v`) : '';
