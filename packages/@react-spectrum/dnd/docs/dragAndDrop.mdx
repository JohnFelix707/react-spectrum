{/* Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License. */}

import {Layout} from '@react-spectrum/docs';
export default Layout;

import ChevronRight from '@spectrum-icons/workflow/ChevronRight';
import docs from 'docs:@react-spectrum/dnd';
import dndDocs from 'docs:@react-types/shared/src/dnd.d.ts';
import {FunctionAPI, PageDescription, TypeContext, InterfaceType} from '@react-spectrum/docs';
import {Keyboard} from '@react-spectrum/text';

---
category: Concepts
keywords: [drag and drop, dnd]
after_version: 3.0.0
order: 6
---

# Drag and Drop

This page describes how to enable drag and drop functionality for the various React Spectrum components that support it.

## Introduction

Drag and drop is an operation performed when a user "grabs" a UI element via their pointing device and drops it on a different location or element.
It has become a common interaction in many modern applications due to its flexibility across a variety of use cases but can come saddled with
many accessibility issues, including but not limited to keyboard interaction parity and difficulties mimicking drag operations with mouse emulators.
React Spectrum collection components that support drag and drop operations seek to address these issues by providing full keyboard and screen reader drag and drop
support.

## Drag and Drop Concepts

Before we dive into how to enable and use drag and drop in React Spectrum, let touch briefly on the concepts of drag and drop. In any drag and drop operation, there is always
a **drag source** and a **drop target**. The drag source is the starting location of your dragged data and the drop target is its intended destination. The dragged data
is made up of one or more **drag items**, each of which contains information specific to their respective item within the drag source.

A drag item provides two pieces of information: the **type** of the data and the actual data itself. The type of a drag item could be one of the
[standard mime types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types) or a custom type specific to your application. A drag item can support
multiple types so that the same data can be provided in different formats for interoperability with various drop targets. For example, an image could be represented by a
`image/jpeg` type and thus be recognized as a JPEG by a file upload drop target but also have a `plain/text` type that allows the image's file name to be communicated to a
text input drop target.

When performing a drag operation, drop targets can specify what **drop positions** they allow. A collection component, such as a list or a table, may support a `root` drop position,
allowing items to be dropped on the collection as a whole. It may also support `on` drop positions, such as when dropping into a folder in a list. If the collection supports reordering of
its items, it could support `between` drop positions, allow the user to insert items between other items. A drop target can support as many drop positions as it needs and can use the makeup
of the dragged items to selectively allow or disallow certain positions.

There are several **drop operations** that can be performed in a drag and drop operation: `move`, `copy`, `link`, and `cancel`. A `move` operation indicates that the dragged data should be
moved from its source location to the target location. A `copy` operation indicates that the dragged data should be copied to the target destination. A `link` operation indicates that
there should be a relationship made between the source and target locations. Finally, a `cancel` operation indicates that the drag and drop operation should be canceled, resulting in
no changes made to the source or target. A drag source can specify what drop operations are allowed for its data and the drop source decides what operation to perform on drop, utilizing the restrictions
set by the drag source as a guideline.

### Interaction modes

There are several interaction models that need to be considered for drag and drop. When using a mouse, you can click an item and drag by holding the mouse button down and moving the pointer. A drop can
then be performed by releasing the mouse button or canceled by the <Keyboard>Esc</Keyboard> key. Similar interactions can performed via touch, with a drag started after a long press in order to distinguish
from scroll or swipe gestures and a drop performed by removing your finger from the screen. In both cases, selecting and dragging a item is often accompanied by a **drag preview**. The drag preview
is typically a smaller version of the dragged item that follows the cursor or touch point. When multiple items are dragged at once, a badge or some other visual affordance is displayed to indicate
that multiple items are being dragged. Drop targets are often visually highlighted when dragging over them and the desired drop operation can be controlled via modifier key presses or drop activations
through hovering over the drop target for a period of time.

For keyboards, copy and paste shortcuts have traditionally been the alternative method to drag and drop. This comes with many limitations as it is often hard to know where pasting is allowed and to control the
exact positioning of your pasted items. Touch screen readers are even more limited in their ability to perform these operations since they often lack access to a keyboard for these interactions. React Spectrum
attempts to resolve these limitations by providing interactive drag affordances that brings a user into drag and drop mode when triggered via keyboard or screen reader virtual click. See the
[Accessibility section](#accessibility) below for further explanation on how this works.

## Example

```tsx example
import {Flex} from '@react-spectrum/layout';

<Flex gap="size-300">
  <DraggableList />
  <DroppableList />
</Flex>
```

### Accessibility

To perform a drag and drop operations via a keyboard, first select the items to be dragged. You can then start the drag operation by focusing the drag handle on any of the
selected rows and hitting <Keyboard>Enter</Keyboard>/<Keyboard>Space</Keyboard>. Once a drag operation is started, you will be automatically brought to the first valid drop target.
<Keyboard>Tab</Keyboard> can then be used to cycle through other valid drop targets. For collection components like the ListView above, <Keyboard>Tab</Keyboard> will move you on or off
the overall component itself whereas <Keyboard>ArrowUp</Keyboard> and <Keyboard>ArrowDown</Keyboard> will cycle through the valid drop targets within the component itself.
Hitting <Keyboard>Enter</Keyboard> will then confirm the drop operation on the focused drop target. To cancel a drag operation, you can hit <Keyboard>Esc</Keyboard> at any time.

For screen readers, please follow the instructions announced when focusing the row's drag handle to begin a drag operation. For screen readers on mobile devices, swiping left and right should
move you between valid drop targets and double tapping should confirm a drop operation. Go ahead and try out drag and drop in the example above!

### Creating the draggable list

For the first ListView in the example above, we want to make the rows draggable and have the dragged rows removed from the list upon a successful drop. To accomplish this,
we first want to setup the initial list of items for our draggable ListView via [useListData](/react-stately/useListData.html) so that we have access to some helper methods
to modify the list of items on the fly.

```tsx example render=false
let list = useListData({
  initialItems: items || [
    {id: 'a', textValue: 'Adobe Photoshop', type: 'file'},
    {id: 'b', textValue: 'Adobe XD', type: 'file'},
    {id: 'c', textValue: 'Adobe Dreamweaver', type: 'file'},
    {id: 'd', textValue: 'Adobe InDesign', type: 'file'},
    {id: 'e', textValue: 'Adobe Connect', type: 'file'}
  ]
});
```

Next, we need to specify the data associated with each dragged item via the array returned by `getItems`. In this case, we look up the information for each dragged item and
serialize it, mapping it to the items type. This information will be processed and provided to the drop target's drop handlers on drop.

```tsx example render=false
function getItems(keys) {
  return [...keys].map(key => {
    let item = list.getItem(key);
    return {
      [item.type]: JSON.stringify(item)
    };
  })
}
```

We also create a `onDragEnd` event handler for `useDragHooks` that handles removing the dragged items from the draggable list upon a successful drop operation. Note how we use
the `.remove` method provided by `useListData` to remove the dropped items from our list.

```tsx example render=false
function onDragEnd(e) {
  if (e.dropOperation === 'move') {
    list.remove(...e.keys);
  }
}
```

Finally, we simply provide our `getItems` and `onDragEnd` functions as options to `useDragHooks`, providing us with a set of `dragHooks` that we can pass to our ListView directly.
Below is what our draggable ListView would look like after combining everything together. For more info on `getItems` and `onDragEnd`, see the [API section](#api) below.

```tsx example export=true render=false
import {Item, ListView} from '@react-spectrum/list';
import {useDragHooks} from '@react-spectrum/dnd';
import {useListData} from '@react-stately/data';

function DraggableList(props) {
  let {
    items,
    ...otherProps
  } = props;
  let list = useListData({
    initialItems: items || [
      {id: 'a', textValue: 'Adobe Photoshop', type: 'file'},
      {id: 'b', textValue: 'Adobe XD', type: 'file'},
      {id: 'c', textValue: 'Adobe Dreamweaver', type: 'file'},
      {id: 'd', textValue: 'Adobe InDesign', type: 'file'},
      {id: 'e', textValue: 'Adobe Connect', type: 'file'}
    ]
  });

  let dragHooks = useDragHooks({
    getItems: (keys) => [...keys].map(key => {
      let item = list.getItem(key);
      return {
        [item.type]: JSON.stringify(item)
      };
    }),
    onDragEnd: (e) => {
      if (e.dropOperation === 'move') {
        list.remove(...e.keys);
      }
    }
  });

  return (
    <ListView
      aria-label="Draggable list view example"
      width="size-3600"
      height="size-3600"
      selectionMode="multiple"
      items={list.items}
      dragHooks={dragHooks}
      {...otherProps}>
      {item => (
        <Item key={item.key}>
          {item.textValue}
        </Item>
      )}
    </ListView>
  );
}
```

### Creating the droppable list

For the second ListView, we want to make it droppable but have it only accept root level drops. Similar to the draggable ListView, we'll start by initializing the default item list
via [useListData](/react-stately/useListData.html).

```tsx example render=false
let list = useListData({
  initialItems: items || [
    {id: 'f', textValue: 'Adobe AfterEffects', type: 'file'},
    {id: 'g', textValue: 'Adobe Illustrator', type: 'file'},
    {id: 'h', textValue: 'Adobe Lightroom', type: 'file'},
    {id: 'i', textValue: 'Adobe Premiere Pro', type: 'file'},
    {id: 'j', textValue: 'Adobe Fresco', type: 'file'}
  ]
});
```

To implement root level only drops, we create a `getDropOperation` function that returns `"cancel"` for any drop target other than `root` and if the dragged item types doesn't include
`'file'`.

```tsx example render=false
function getDropOperation(target, types) {
  if (target.type !== 'root' || !types.has('file')) {
    return 'cancel';
  }

  return 'move';
}
```

Next, we create a `onDrop` event handler to process the successfully dropped items. This `onDrop` handler first checks each dropped item's kind and type, extracting the item's
relevant information if it detects it has the expected types. This information is used to construct an array of items to add to the list and then inserting them to the end of the
droppable list.

```tsx example render=false
async function onDrop(e) {
  let itemsToAdd = [];
  for (let item of e.items) {
    if (item.kind === 'text' && item.types.has('file')) {
      let {type, id, textValue} = JSON.parse(await item.getText('file'));
      if (!!type && !!id && !!textValue) {
        itemsToAdd.push({
          id,
          type,
          textValue
        });
      }
    }
  }
  list.append(...itemsToAdd);
}
```

Finally, we simply provide our `getDropOperation` and `onDrop` functions as options to `useDropHooks`, providing us with a set of `dropHooks` that we can pass to our ListView directly.
Below is what our droppable ListView would look like after combining everything together. For more info on `getDropOperation` and `onDrop`, see the [API section](#api) below.

```tsx example export=true render=false
import {useDropHooks} from '@react-spectrum/dnd';

function DroppableList(props) {
  let {
    items,
    ...otherProps
  } = props;
  let list = useListData({
    initialItems: items || [
      {id: 'f', textValue: 'Adobe AfterEffects', type: 'file'},
      {id: 'g', textValue: 'Adobe Illustrator', type: 'file'},
      {id: 'h', textValue: 'Adobe Lightroom', type: 'file'},
      {id: 'i', textValue: 'Adobe Premiere Pro', type: 'file'},
      {id: 'j', textValue: 'Adobe Fresco', type: 'file'}
    ]
  });

  let dropHooks = useDropHooks({
    getDropOperation: (target, types) => {
      if (target.type !== 'root' || !types.has('file')) {
        return 'cancel';
      }

      return 'move';
    },
    onDrop: async (e) => {
      let itemsToAdd = [];
      for (let item of e.items) {
        if (item.kind === 'text' && item.types.has('file')) {
          let {type, id, textValue} = JSON.parse(await item.getText('file'));
          if (!!type && !!id && !!textValue) {
            itemsToAdd.push({
              id,
              type,
              textValue
            });
          }
        }
      }
      list.append(...itemsToAdd);
    }
  });

  return (
    <ListView
      aria-label="Droppable list view example"
      width="size-3600"
      height="size-3600"
      selectionMode="multiple"
      items={list.items}
      dropHooks={dropHooks}
      {...otherProps}>
      {item => (
        <Item key={item.key}>
          {item.textValue}
        </Item>
      )}
    </ListView>
  );
}
```

## API

<FunctionAPI function={docs.exports.useDragHooks} links={docs.links} />
<TypeContext.Provider value={dndDocs.links}>
  <InterfaceType properties={dndDocs.exports.DraggableCollectionProps.properties} />
</TypeContext.Provider>

<TODO: add line break here>

<FunctionAPI function={docs.exports.useDropHooks} links={docs.links} />
<TypeContext.Provider value={dndDocs.links}>
  <InterfaceType properties={dndDocs.exports.DroppableCollectionProps.properties} />
</TypeContext.Provider>

As seen in the [example](#example) above, enabling drag and drop for a supported React Spectrum component differs slightly from the typical event handler prop pattern that you may be familiar with.
Instead of providing each event handler directly to the component, you must first import `useDragHooks` and `useDropHooks` from the `@react-spectrum/dnd` package
and provide those hooks with your desired options.

`useDragHooks` will then provide you with a set of drag hooks that you can pass to the component via its `dragHooks` prop, thus enabling drag operations for the component.
Drop operations can be enabled in the same way by passing the hooks from `useDropHooks` to the component's `dropHooks` prop.

Of the various hook options above, `getAllowedDropOperations` and `getDropOperation` may be of particular interest since it allows you to specify what kinds of drag and drop operations you want to allow.
When the dragged items are dropped on a drop target created using the React Aria drag and drop hooks, the allowed drop operations you return in `getAllowedDropOperations`
are provided to the drop target's `getDropOperation`, giving the drop target extra information which it can use to decide what drop operation to execute. This in turn provides
the `onDragEnd` and `onDrop` handlers with the executed drop operation, allowing you to decide what to do with the dragged items in your original collection and in the dropped collection.

For instance, you may have a draggable collection of items that allows `move` and `copy` operations but you need a way to know whether or not you should be removing the dragged items
from the list after a drop operation. A drop target that only allows `copy` operations, such as a file upload drop zone, would be able to return `copy` from its `getDropOperation` and communicate that
to your draggable collection's `onDragEnd` handler, letting it know that it shouldn't remove the dragged items from the list. Alternatively, a drop target that allows `move` operations, like in the
[example](#example) above, would return `move` from its `getDropOperation` and thus inform your draggable collection to remove the dragged items from it list.

You may be wondering why we didn't simply import the drag and drop hooks within the components themselves. The reason behind this is to reduce the bundle size of
the component for users who don't need the drag and drop support for their component.

## Supported components

The following list shows which components currently support drag and drop. Common drag and drop implementations are included in each component's documentation so definitely take a look!
-  [ListView](ListView.html#drag-and-drop)
